---
layout: post
title: Estimating pi with GIS and Monte Carlo
published: false
excerpt: >
  Using Monte Carlo methods, randomly placed spatial objects, and topological 
  operations in R to estimate pi.  
category: Spatial
tags: R Spatial GIS Monte-Carlo
---

```{r}
library(sp)
library(raster)
library(rgdal)
library(rgeos)
library(dplyr)
library(ggplot2)
```

While reading the Wikipedia page on [Monte Carlo methods](https://en.wikipedia.org/wiki/Monte_Carlo_method) recently I came across two interesting spatial approaches to estimating \\( \\pi \\). Both involved random placing a large spatial objects in a place (points and lines, respetively), performing some topological operations (testing for containment and intersection, respectively), and summarizing over all spatial objects to estimate \\( \pi \\). While both approaches are probably more easily and efficiently done outside of a GIS, I thought it would be fun to try them using some of the spatial objects and spatial analyis tools in R.  

## Monte Carlo Methods  

The fact that I was reading about Monte Carlo on Wikipedia is a pretty good indication of the amount I know about these techniques (not much!). So, I'll resort to the concise definintion from [Wolfram](http://mathworld.wolfram.com/MonteCarloMethod.html):  

> Any method which solves a problem by generating suitable random numbers and observing that fraction of the numbers obeying some property or properties.  

This definition is a bit vague because the term encompasses a very broad class of algorithms spanning many disciplines. The key seems to be the use of repeated draws of random numbers from some probability distribution to solve a complex problem or simulate a complex system. I think the following two examples will make this more concrete.  

## Incribed Circle Approach  

[Wikipedia](https://en.wikipedia.org/wiki/Monte_Carlo_method#Introduction) gives the following method for estimating \\( \\pi \\) as a simple example of a Monte Carlo method:  

1.  Draw a square with a circle inscribed within it. Note that the ratio of the areas of the circle and square is \\( \\pi / 4 \\).  
2.  Randomly distribution a large number of points over the square, such that there is a uniform probability of a given point being anywhere within the square.  
3.  Count the number of points inside the circle and the total number of points.  
4.  The ratio of the numbers of points will equal the ratio of the areas (i.e. \\( \\pi / 4 \\)), so multiplying this ratio by 4 will give an estimate of  \\( \\pi \\).  

To see where the area ratio of \\( \\pi / 4 \\) comes from, note that a square with side length \\( s \\) has area \\( s^2 \\), and a circle incribed within this square will have radius \\( s / 2 \\) and hence area \\(s ^ 2 / 4 \\). The Wikipedia page has a nice animated visual representation of this technique:  

![Inscribed circle approach](https://upload.wikimedia.org/wikipedia/commons/8/84/Pi_30K.gif)  

### R Implementation  

First I draw a square with a circle inscribed.  

```{r square-circle}
square <- readWKT('POLYGON((-1 -1,-1 1,1 1,1 -1, -1 -1))')
circle <- readWKT('POINT(0 0)') %>% 
  gBuffer(width = 1, quadsegs = 25)
plot(square, axes = F, border = '#FA6900', lwd = 2)
plot(circle, add = T, col = '#69D2E7', border = 'transparent')
```

[Well-known Text](https://en.wikipedia.org/wiki/Well-known_text) is a simple markup language for representing vector geometries in plain text, and `rgeos::readWKT()` creates spatial objects based on a WKT strings. It's the easiest way I know of to quickly create simple geometries in R. To create the circle I create a buffer around I point. The `quadsegs` parameter in `rgeos::gBuffer()` sets the number of line segments to use to approximate a quarter circle, which is a measure of the smoothness of the buffering polygon. The default value of `quadsegs = 5` results in a circle with noticable edges, but `quadsegs = 25` seems to create a nice smooth circle.  

Next I randomly sample a large number points within this square using `sp::spsample()`.  

```{r spsample}
n_pts <- 1000
pts <- spsample(square, n_pts, type = 'random')
plot(square, axes = F, border = '#FA6900', lwd = 2)
plot(circle, add = T, col = '#69D2E7', border = 'transparent')
plot(pts, add = T, pch = 21, cex = 0.25, col = '#333333')
```

There are a few ways determine which of these points are within the circle. First, the function `over(x, y)` in the `sp` package gives the indexes of spatial object `y` at the spatial locations of object `x`. If a given feature in `x` is not contained within `y` `NA` is returned.  

```{r over}
over(pts, circle) %>% 
  sum(na.rm = T)
```

Alternatively, the `sp` package offers an idiom of sorts to extract the features in one geometry that are within another geometry.  

```{r idiom}
(pts_within <- pts[circle, ])
length(pts_within)
```

In addition to these methods in the `sp` package, the `rgeos` package provides a more complete set of topological operations. `gIntersects()` tests if two geometries overlap, either overall (with `byid = F`) or on at the level of individual features (with `byid = T`).  

```{r gintersects}
n_within <- gIntersects(pts, circle, byid = T) %>% 
  sum
n_within
```

Finally, taking the ratio of points within the circle to total points and multiplying by 4, gives an estimate of \\( \\pi \\).  

```{r crude-estimate}
(pi_est <- 4 * n_within / n_pts)
round(abs(100 * (pi_est / pi - 1)), 2)
```

So, with `r n_pts` points we get an error of about `r round(abs(100 * (pi_est / pi - 1)), 2)`%; not too bad!  

### Convergence  

To see how the estimates from this approach converge to the true value of \\( \\pi \\), I repeat the process for a dfferent numbers of points. First, I'll write a simple function to estimate pi based on a given number of points. Out of curiosity, I also time it.  

```{r function}
estimate_pi <- function(n_pts) {
  t <- system.time({
    square <- readWKT('POLYGON((-1 -1,-1 1,1 1,1 -1, -1 -1))')
    circle <- readWKT('POINT(0 0)') %>% 
      gBuffer(width = 1, quadsegs = 25)
    n_within <- spsample(square, n_pts, type = 'random') %>% 
      gIntersects(circle, byid = T) %>% 
      sum
    pi_estimate <- (4 * n_within / n_pts)
  })
  return(data.frame(pi_estimate, t = t[['user.self']]))
}
estimate_pi(1e4)
```

And I run with for a range of values of `n_pts`, esimating \\( \\pi \\) multiple times at each to get a sense of the variable.  

```{r big-run}
n_values <- 10^(2:7)
n_reps <- 10
estimates <- expand.grid(n_values, 1:n_reps) %>% 
  setNames(c('n_pts', 'run')) %>% 
  tbl_df %>% 
  group_by(n_pts, run) %>% 
  do(estimate_pi(.$n_pts))
```

```{r}
ci <- function(x) {
  qt(0.975, df = length(x) - 1) * sd(x) / sqrt(length(x))
}
se <- function(x) {
  sd(x) / sqrt(length(x))
}
estimates %>% 
  group_by(n_pts) %>% 
  summarize(pi_mean = mean(pi_estimate),
            pi_ci = ci(pi_estimate),
            pi_se = se(pi_estimate),
            t_mean = mean(t)) %>% 
  ggplot(aes(x = n_pts, y = pi_mean)) +
    geom_point() +
    geom_errorbar(aes(ymin = pi_mean - pi_se, ymax = pi_mean + pi_se)) +
    geom_line() +
    geom_hline(aes(yintercept=pi), color = 'red', linetype = 'dashed') +
    scale_x_log10()
```



## Buffon's Needle  

https://en.wikipedia.org/wiki/Buffon%27s_needle


