---
layout: post
title: Parallel Optimization via Simulated Annealing in R 
published: true
excerpt: >
  Running simulated annealing in parallel using R's optim function.   
category: R
tags: R Marxan
---


# Context  

**Feel free to skip this if you don't care about spatial conservation prioritization.**  

Spatial conservation prioritization is all about optimization: choosing where to invest to get the most conservation benefit for a limited conservation budget. In systematic reserve design, the goal is to find a set of reserves that maximizes the attainment of a well defined set of biodiversity targets, while minimizing the overall cost. This is formalized mathematically as an **objective function** that is to be maximized. This is not a trivial problem to solve. The landscape is typically divided up into a large number of equally sized planning units and the goal is to decide which should be included and which excluded from the reserve network. For just 100 planning units, there are \\( 100^2 \\approx 10^30$  \\) possible reserve configurations, a massive number! And in a real worth problem there would be many thousands of planning units.  

Fortunately, the software [Marxan](www.uq.edu.au/marxan/) exists to solve just this problem. Under the hood, Maraxan uses a technique called [simulated annealing](https://en.wikipedia.org/wiki/Simulated_annealing) to minimize the objective function. Unlike a true optimization algorithm, simulated annealing doesn't find the precise global optimum, rather it finds an acceptable, near optimal solution. Thus, in Marxan, the user typically runs the annealing process many times to generate a suite of candidate reserve networks that are used to inform decision making on the ground.  

The point of all this context, is that since the annealing process need to be run multiple times independently, it's a great candidate for parallelization. I've been using R's `optim` function in the `stats` package to solve reserve design problems similar to Marxan, so I've recently been playing around with R's options for running processes in parallel. Turns out parallelization is a breeze in R!  

```{r}
system.time(results <- lapply(1:100000, sqrt))

(n_cores <- detectCores())
cl <- makeCluster(n_cores)
system.time(results_p <- clusterApply(cl, 1:100, sqrt))
stopCluster(cl)
```

```{r}
library(doMC)
fw <- function (x) {
  10 * sin(0.3 * x) * sin(1.3 * x^2) + 0.00001 * x^4 + 0.2 * x + 80
}
result <- optim(50, fw, method = "SANN",
      control = list(maxit = 20000, temp = 20, parscale = 20))

t_seq <- system.time({
  results_foreach <- foreach(i = 1:10) %do% {
    r <- optim(50, fw, method = "SANN",
                 control = list(maxit = 200000, temp = 20, parscale = 20))
    r[c('par', 'value')]
  }
})

registerDoMC(cores = 2)
t_par <- system.time({
  results_foreach <- foreach(i = 1:10) %dopar% {
    print(environment())
    r <- optim(50, fw, method = "SANN",
                 control = list(maxit = 200000, temp = 20, parscale = 20))
    r
    r[c('par', 'value')]
  }
})
registerDoSEQ()

t_par
t_seq
```

```{r}
pow_n <- function(n) {
  counter <- 0
  function(x) {
    counter <<- counter + 1
    print(sprintf('Fuction exectured %i times.', counter))
    x^n
  }
}
pow_5 <- pow_n(5)
duplicate_function <- function(f) {
  dupe_f <- f
  environment(dupe_f) <- new.env()
  list2env(as.list(environment(f)), envir= environment(dupe_f))
  dupe_f
}
registerDoMC(cores = 2)
foreach_pow <- foreach(i = 1:10) %do% {p <- duplicate_function(pow_5); p(i)}
registerDoSEQ()

x <- 1
times(10) %dopar% {x <- x + 1; x}

pow_5 <- pow_n(5)
pow_copy <- duplicate_function(pow_5)
environment(pow_5)
environment(pow_copy)
environment(pow_5) %>% 
  {mget(ls(.), envir = .)}
environment(pow_copy) %>% 
  {mget(ls(.), envir = .)}
pow_5(1)
pow_5(2)
environment(pow_5) %>% 
  {mget(ls(.), envir = .)}
environment(pow_copy) %>% 
{mget(ls(.), envir = .)}


xxx <- function(x) {
  print(x)
}
environment(xxx) <- new.env()
xxx(234)

myl <- list(list(a=1:10, b='A', c=letters[1:5]), list(a=11:20, b='B', c=letters[6:10]))
do.call(cbind, lapply(myl, `[[`, 'a'))
```


