---
layout: post
title: "Fishnets and Honeycomb: Square vs. Hexagonal Spatial Grids"
published: true
excerpt: >
  Considering the benefits of hexagonal grids relative to square grids for 
  spatial sampling and analysis, and generating hexagonal grids in R.
category: spatial
tags: r spatial gis
---

```{r echo = F, include = F, eval = F}
setwd('_source/')
```

In spatial analysis, we often define [grids](https://en.wikipedia.org/wiki/Grid_(spatial_index)) of points or polygons to sample, index, or partition a study area. For example, we may want to overlay a study area with a grid of points as part of some regular spatial sampling scheme, divide a large region into smaller units for indexing purposes as with UTM grid zones, or slice the study area into subunits over which we summarize a spatial variable. In the latter scenario, the most common approach is to use a raster format, in which a grid of uniform square cells is overlayed on a study area and each cell is assigned a value for the spatial variables of interest. In ecology and conservation applications, variables may include number of individuals of a threatened species per grid cell, elevation, mean annual rainfall, or land use.

From my experience, using square cells is by far the most common method for defining grids; however, other options are possible. In fact, any [regular tesselation of the plane](https://en.wikipedia.org/wiki/Euclidean_tilings_by_convex_regular_polygons) (i.e. the tiling of a plane with contiguous regular polygons of the same type), can act as a spatial grid. Tessellation is well studied mathematically and there are just [three possible regular tesselations](https://en.wikipedia.org/wiki/Euclidean_tilings_by_convex_regular_polygons#Regular_tilings): equilateral triangles, squares, and regular hexagons. A forth option is a diamond pattern arising from merging pairs of equilateral triangles; however diamonds are not regular polygons. The following images from Wikipedia<sup id="a1">[1](#f1), [2](#f2), [3](#f3)</sup> demonstrate these tessellations:

<div style="text-align: center">
  <img src="/img/2016-01-04-hexagonal-grids/1-uniform_n11.svg" style="width: 30%;" />
  <img src="/img/2016-01-04-hexagonal-grids/1-uniform_n5.svg" style="width: 30%;" />
  <img src="/img/2016-01-04-hexagonal-grids/1-uniform_n1.svg" style="width: 30%;" />
</div>

Recently I've seen a few instances of the use of hexagonal grids, especially in systematic reserve design, and I've become curious about the benefits (and drawbacks) of using them compared to the traditional square grid. In this post I'll discuss the relative benefits and show how to generate different types of grids in R. 

# Comparing Benefits

I begin by comparing the benefits of square and hexagonal grids. Most of these points come directly from [this excellent GIS StackExchange question](http://gis.stackexchange.com/questions/82362/what-are-the-benefits-of-hexagonal-sampling-polygons).

## Square grids

Raster datasets are the most ubiquitous type of square grid used in GIS. The most notable benefits of this format compared to hexagonal grids are:

- **Simplicity of definition and data storage**: the only explicitly geographical information required to define a raster grid are the coordinates of the  origin (e.g. bottom left corner), the cell size, and grid dimensions (i.e. number of cells in each direction). The attribute data can be stored as an aspatial matrix, and the geographical location of any cell can be derived given that cell's position relative to the origin. This makes data storage and retrieval easier since the coordinates of the vertices of each grid cell are not explicitly stored.
- **Ease of resampling to different spatial scales**: increasing the spatial resolution of a square grid is just a matter of dividing each grid cell into four. Similarly, decreasing the spatial resolution only requires combining groups of four cells into one, typically with some algebraic operation to aggregate the attribute data to the coarser resolution.
- **Relationships between cells is given**: there is no need for computationally expensive spatial operations to determine distances or the adjacency relationship between cells.
- **Combining raster layers is simple**: algebraic operations combining multiple raster layers built on the same template simplifies to matrix algebra; no spatial operations are required.

## Hexagonal grids

Regular hexagons are the closest shape to a circle that can be used for the regular tessellation of a plane and the have additional symmetries compared to squares. These properties give rise to the following benefits.

- **Reduced edge effects**: a hexagonal grid gives the lowest perimeter to area ratio of any regular tessellation of the plane. In practice, this means that edge effects are minimized when working with hexagonal grids. This is essentially the same reason [beehives are built from hexagonal honeycomb](https://en.wikipedia.org/wiki/Honeycomb_conjecture): it is the arrangement that minimizes the amount of material used to create a lattice of cells with a given volume.
- **All neighbours are identical**: square grids have two classes of neighbours, those in the cardinal directions that share an edge and those in diagonal directions that share a vertex. In contrast, a hexagonal grid cell has six identical neighbouring cells, each sharing one of the six equal length sides. Furthermore, the distance between centroids is the same for all neighbours.
- **Better fit to curved surfaces**: when dealing with large areas, where the curvature of the earth becomes important, hexagons are better able to fit this curvature than squares. This is why soccer balls are constructed of hexagonal panels.
- **They look badass**: it can't be denied that hexagonal grids look way more impressive than square grids!

# Working with Grids in R

## Required packages

```{r packages}
library(sp)
library(raster)
library(rgeos)
```

## Study region

In the following demostrations, I'll use Sri Lanka as an example study area. The `getData()` function from the `raster` package downloads country boundaries from the [Global Administrative Areas (GADM) Database](http://www.gadm.org/). I clean this up a little by removing the attribute information and any polygons other than the main island of Sri Lanka.

```{r study-region, echo=-1, fig.width=400/96, fig.height=600/96}
par(mar=c(2, 2, 1, 1))
study_area <- getData("GADM", country = "LKA", level = 0, path = "data/") %>% 
  disaggregate() %>% 
  geometry()
study_area <- sapply(study_area@polygons, slot, "area") %>% 
  {which(. == max(.))} %>% 
  study_area[.]
row.names(study_area) <- "1"
plot(study_area, col = "grey50", bg = "light blue", axes = TRUE)
text(81.5, 9.5, "Study Area:\nSri Lanka")
```

## Creating grids

### Hexagonal grids

There is no function in R that will directly generate a hexagonal grid of polygons covering a given region; however, it can be accomplished by first genrating a hexagonal grid of points with `spsample`, then converting this point grid to a grid of polygons with `HexPoints2SpatialPolygons`.

```{r hex-grid, echo=-1, fig.width=400/96, fig.height=600/96}
par(mar=c(2, 2, 1, 1))
size <- 0.5
hex_points <- spsample(study_area, type = "hexagonal", cellsize = size)
hex_grid <- HexPoints2SpatialPolygons(hex_points, dx = size)
plot(study_area, col = "grey50", bg = "light blue", axes = TRUE)
plot(hex_points, col = "black", pch = 20, cex = 0.5, add = T)
plot(hex_grid, border = "orange", add = T)
```

A few issues arise with this simple method:

1. `spsample` generates a different grid of points each time it's called because the grid offset is chosen randomly by default. This can be fixed by setting the offset parameter explicitely with `offset = c(0.5, 0.5)`.
2. Only cells whose centroid is fully within the study area polygon are created. By buffering the study area it's possible to get full coverage by the grid, which is usually what is desired.
3. In some cases it may be desirable to clip the grid to the study area polygon so that cells on the edge match the shape of the study area. This seems to often be the case when setting up a grid of planning units for systematic reserve design. For example, the official [Marxan tutorial](http://www.uq.edu.au/marxan/intro-info) takes this approach. Clipping can be performed using `rgeos::gIntersection()`.
4. The resolution of the grid is determined by the `cellsize` parameter, which is the distance (\\( d \\)) between centroids of neighbouring cells. Other ways of definining cell size are the area (\\( A \\)), side length (\\( s \\)), or radius (\\( r \\)), and these are all related by:

$$
A = \frac{3\sqrt{3}}{2}s^2=2\sqrt{3}r^2=\frac{\sqrt{3}}{2}d^2
$$

I incorporate all these refinements into a function that generates hexagonal grids.

```{r grid-function}
make_grid <- function(s, cell_diameter, cell_area, clip = FALSE) {
  if (missing(cell_diameter)) {
    if (missing(cell_area)) {
      stop('Must provide cell_diameter or cell_area')
    } else {
      cell_diameter <- sqrt(2 * cell_area / sqrt(3))
    }
  }
  s_buffer <- gBuffer(s, width = cell_diameter)
  # generate array of hexagon centers
  g <- spsample(s_buffer, type = "hexagonal", cellsize = cell_diameter, 
                offset = c(0.5, 0.5))
  # convert center points to hexagons
  g <- HexPoints2SpatialPolygons(g, dx = cell_diameter)
  # clip to boundary of study area
  if (clip) {
    g <- gIntersection(g, s, byid = T)
  } else {
    g <- g[s, ]
  }
  # clean up feature IDs
  row.names(g) <- as.character(1:length(g))
  return(g)
}
```

Using this function I generate a grid of \\( 625km^2 \\) (\\( 25km \\) by \\( 25km \\)) cells with and without clipping. This requires projecting the study area polygon to measure distance in kilometers.

```{r nice-grid, echo=-1, fig.width=600/96, fig.height=600/96}
par(mar = c(0.25, 0.25, 0.25, 0.25), mfrow = c(1, 2))
study_area_utm <- CRS("+proj=utm +zone=44 +datum=WGS84 +units=km +no_defs") %>% 
  spTransform(study_area, .)
# without clipping
hex_grid <- make_grid(study_area_utm, cell_area = 625, clip = FALSE)
plot(study_area_utm, col = "grey50", bg = "light blue", axes = FALSE)
plot(hex_grid, border = "orange", add = T)
box()
# with clipping
hex_grid <- make_grid(study_area_utm, cell_area = 625, clip = TRUE)
plot(study_area_utm, col = "grey50", bg = "light blue", axes = FALSE)
plot(hex_grid, border = "orange", add = T)
box()
```

### Square grid

Creating and working with raster datasets in R is well covered elsewhere, for example in the vignettes for the `raster` package, so I won't delve too deeply into it. Briefly, `RasterLayer` objects can easily be created that cover the extent of a `Spatial*` object. I use a cell size of \\( 625km^2 \\) to match the above hexagonal grid, and fill the raster with binary data indicating whether cells are inside or outside the study area.

```{r raster, echo=-1, fig.width=400/96, fig.height=600/96}
par(mar = c(0.25, 0.25, 0.25, 0.25))
r <- raster(study_area_utm, resolution = 25)
r <- rasterize(study_area_utm, r, field = 1)
plot(r, col = "grey50", axes = FALSE, legend = FALSE)
plot(study_area_utm, add = TRUE)
```

In addition to the raster formats defined in the `raster` package, the `sp` package offers several options for square grids. The class `SpatialPixels` is used for partial grids (i.e. not every cell included) and stores the coordinates of all included cell centers. `SpatialGrid` objects store full grids and do not store coordinates explicitely. Underlying both classes is the `GridTopology` class, which stores the grid template (origin, cell size, and dimensions). I never use these classes since the `raster` classes and methods are more intuitive and efficient.

The final option from the `sp` package is simply to store a square grid as polygons (`SpatialPolygons` object), just as I did with the hexagonal grids above. In this case, I find the easiest way to define a grid of square polygons is to start with an empty `RasterLayer` object and coerce it to `SpatialPolygons`.

```{r square-polys}
square_grid <- raster(study_area_utm, resolution = 25) %>% 
  as(r, 'SpatialPolygons')
```

<div class="footnotes">
  <p><strong>Footnotes</strong></p>
  <p><strong id="f1">1</strong> 
    "1-uniform n11" by Tomruen - Own work. Licensed under CC BY-SA 4.0 via Commons - https://commons.wikimedia.org/wiki/File:1-uniform_n11.svg [↩](#a1)
    </p>
  <p><strong id="f2">2</strong> 
    "1-uniform n5" by Tomruen - Own work. Licensed under CC BY-SA 4.0 via Commons - https://commons.wikimedia.org/wiki/File:1-uniform_n5.svg [↩](#a1)
  </p>
  <p><strong id="f3">3</strong> 
    "1-uniform n1" by Tomruen - Own work. Licensed under CC BY-SA 4.0 via Commons - https://commons.wikimedia.org/wiki/File:1-uniform_n1.svg [↩](#a1)
    </p>
<small>