---
layout: post
title: "Open-source Integer Linear Progamming Solver Performance Comparison"
published: true
excerpt: >
  Comparing the performance of open-source integer linear programming solvers.
  The focus is on finding an open-source alternative to Gurobi for conservation
  prioritization and proteced area design.
category: prioritization
tags: r gurobi optimization marxan
---

```{r echo = F, include = F, eval = F}
setwd("_source/")
```

```{r setup, echo = F}
knitr::opts_chunk$set(dev = "png", message = FALSE)
```

In this post I'll compare alternative integer linear programming (ILP) solvers for conservation planning. The goal is to develop a tool to solve the Marxan reserve design problem using ILP rather than simulated annealing. Unlike simulated annealing, ILP can find the true global optimum of an optimization problem or, if time constraints are an issue, it can return a solution that is within a specified distance from the optimum. This ability to evaluate the quality of a solution (i.e. distance to optimality), makes IP an excellent candidate for conservation planning.

In a [previous post](http://strimas.com/r/gurobi/), I demonstrated how to use the commercial optimization software [Gurobi](http://www.gurobi.com/). Gurobi is great, but expensive, so in this post I'll explore solving the reserve design problem using free and open-source solvers.

## Packages

```{r packages, message=FALSE}
library(dplyr)
library(sp)
library(raster)
library(rasterVis)
library(viridis)
library(slam)
library(protectr) # devtools::install_github("mstrimas/protectr")
# solvers
library(gurobi)
library(lpSolveAPI)
library(Rsymphony)
library(glpkAPI)
set.seed(1)
```

# Preparation

First, I'll set up the problem and prepare some data.

## Data generation

To test the various methods, I'll generate 9 species distributions and a cost layer over a 10x10 grid of planning units (100 total). I've intentionally chosen an extremely simplified problem to start with to ensure that all the solvers will be able to handle it; later we'll look at different problem sizes. Although fabricated, these layers have some spatial auto-correlation built it to make them semi-realistic.

```{r species}
# raster template
r <- extent(0, 100, 0, 100) %>% 
  raster(nrows = 100, ncols = 100, vals = 1)

# generate 9 feature distributions with different spatial scales and rarities
species <- mapply(function(x, y, r) gaussian_field(r = r, range = x, prop = y),
                  rep(c(5, 15, 25), each = 3),
                  rep(c(0.1, 0.25, 0.5), times = 3),
                  MoreArgs = list(r = r)) %>% 
  stack %>% 
  setNames(., letters[1:nlayers(.)])
levelplot(species, main = 'Species Distributions', layout = c(3, 3),
          scales = list(draw = FALSE),
          col.regions = c("grey20", "#fd9900"), colorkey = FALSE)
# genrate cost layer
cost_raster <- gaussian_field(r, 20, mean = 1000, variance = 500) %>% 
  setNames("cost")
levelplot(cost_raster, main = "Cost", margin = FALSE, col.regions = viridis)
```

## Pre-processing

The various components of the optimization problem need to be prepared. Where possible, I use sparse matrices from the `slam` package to save memory. First, the representation matrix \\( r_{ij} \\) stores the representation level of feature \\( j \\) in planning unit \\( i \\).

```{r rij}
rij <- as.simple_triplet_matrix(t(unname(species[])))
```

I arbitrarily set targets to 30% of the total level of representation across the whole study area.

```{r targets}
targets <- 0.3 * cellStats(species, "sum")
```

Finally, I convert the cost raster to a numeric vector.

```{r cost}
cost <- cost_raster[[1]][]
```

# Solvers

In [my previous post](http://strimas.com/prioritization/ilp-field-guide/), I looked at four linear progamming solvers, accessed via seven R packages. For a [variety of reasons](http://strimas.com/prioritization/ilp-field-guide/#conclusions) outlined in that post, I excluded several packages, leaving me with three potential candidate R packages for an open-source alternative to Gurobi:

- **Solver:** `lp_solve`; **R Package:** `lpSolveAPI`
- **Solver:** SYMPHONY; **R Package:** `Rsymphony`
- **Solver:** GLPK; **R Package:** `glpkAPI`

In [previous post](http://strimas.com/prioritization/ilp-field-guide/), I went throught the process of building up standardized wrapper functions for solving the reserve design problem using these ILP solvers. Consult that post for the function definitions, here I just give the signatures of the wrapper functions.

```{r wrappers, echo=FALSE}
# gurobi
msc_gurobi <- function(cost, rij, targets,
                       gap = 1e-4,
                       time_limit = Inf,
                       first_feasible = FALSE,
                       bound = NA) {
  # construct model
  model <- list()
  # goal is to minimize objective function
  model$modelsense <- "min"
  # binary decision variables
  model$vtype <- "B"
  # objective function
  model$obj <- cost
  # structural constraints
  model$A <- rij
  model$rhs <- targets
  model$sense <- rep(">=", length(targets))

  # stopping conditions
  # gap to optimality
  params <- list(Presolve = -1, MIPGap = gap)
  # stop after specified number of seconds
  if (is.finite(time_limit)) {
    params <- c(params, TimeLimit = time_limit)
  }
  # first feasible solution
  if (first_feasible) {
    params <- c(params, SolutionLimit = 1)
  }
  
  # solve
  t <- system.time(
    results <- gurobi::gurobi(model, params)
  )
  # get rid of log file
  if (file.exists("gurobi.log")) {
    unlink("gurobi.log")
  }
  
  if (is.na(bound)) {
    bound <- results$objbound
  }
  # prepare return object
  list(time = summary(t)[["user"]],
       x = results$x,
       objval = results$objval,
       objbound = bound,
       gap = (results$objval / bound - 1))
}
# lp_solve
msc_lpsolve <- function(cost, rij, targets,
                        gap = 1e-4,
                        time_limit = Inf,
                        first_feasible = FALSE,
                        bound = NA) {
  # construct model with given number of constraints (i.e. features)
  # and decision variables (i.e. planning units)
  model <- lpSolveAPI::make.lp(nrow = nrow(rij), ncol = ncol(rij))
  # goal is to minimize objective function
  lpSolveAPI::lp.control(model, sense = "min")
  # binary decision variables
  lpSolveAPI::set.type(model, columns = seq_along(cost), type = "binary")
  # objective function
  lpSolveAPI::set.objfn(model, obj = cost)
  # structural constraints
  # set non-zero elements of constraint matrix
  for (k in seq_along(rij$v)) {
    set.mat(model, i = rij$i[k], j = rij$j[k], value = rij$v[k])
  }
  lpSolveAPI::set.rhs(model, b = targets)
  lpSolveAPI::set.constr.type(model, types = rep(">=", length(targets)))
  
  # the % gap to optimality at which to terminate
  lpSolveAPI::lp.control(model, 
                         verbose = "normal",
                         #presolve = c("rows", "cols"),
                         # first feasible solution
                         break.at.first = first_feasible,
                         # gap to optimality
                         mip.gap = c(1e-11, gap),
                         # stop after specified number of seconds
                         timeout = ifelse(is.finite(time_limit), time_limit, 0))
  
  # solve
  t <- system.time({
    screen_out <- capture.output(lpSolveAPI::solve.lpExtPtr(model))
  })
  
  # extract lower bound from screen output
  if (is.na(bound)) {
    bound <- stringr::str_subset(screen_out, "Relaxed solution")
    bound <- stringr::str_match(bound, "Relaxed solution\\s+([-+.e0-9]+)")
    bound <- ifelse(nrow(bound) > 0, as.numeric(bound[1, 2]), NA)
  }
  print(screen_out)
  # prepare return object
  results <- list(time = summary(t)[["user"]],
                  x = lpSolveAPI::get.variables(model),
                  objval = lpSolveAPI::get.objective(model),
                  objbound = bound,
                  gap = (lpSolveAPI::get.objective(model) / bound - 1))
  #lpSolveAPI::delete.lp(model)
  return(results)
}
# clp
solve_relaxed_clp <- function(cost, rij, targets) {
  # construct model with given number of constraints (i.e. features)
  # and decision variables (i.e. planning units)
  model <- clpAPI::initProbCLP()
  # goal is to minimize objective function, max = -1, min = 1
  clpAPI::setObjDirCLP(model, lpdir = 1)
  # in vector of non-zero constraint matrix elements need indices for where
  # new columns start
  new_row <- diff(rij$j)
  new_row_i <- which(new_row != 0)
  col_starts <- c(0, rep(new_row_i, times = new_row[new_row_i]), length(rij$i))
  # load optimization problem
  clpAPI::loadProblemCLP(model,
                         # constraint matrix dimensions
                         ncols = ncol(rij), nrows = nrow(rij),
                         # row indices for non-zero elements, 0-indexed
                         ia = (rij$i - 1), 
                         # start indices of new columns, 0-indexed
                         ja = col_starts,
                         ra = rij$v, 
                         # bounds on decision variables
                         lb = rep(0, length(cost)), ub = rep(1, length(cost)),
                         # objective function coefficients
                         obj_coef = cost,
                         # bounds on contraints, i.e. rhs of contraint
                         rlb = targets, rub = NULL)
  clpAPI::setLogLevelCLP(model, amount = 0)
  # solve
  t <- system.time(
    clpAPI::solveInitialCLP(model)
  )
  # prepare return object
  results <- list(time = summary(t)[["user"]],
                  x = clpAPI::getColPrimCLP(model),
                  objval = clpAPI::getObjValCLP(model))
  clpAPI::delProbCLP(model)
  return(results)
}
# symphony
msc_symphony <- function(cost, rij, targets,
                         gap = 1e-4,
                         time_limit = Inf,
                         first_feasible = FALSE,
                         bound = NA) {
  t <- system.time({
    # symphony takes an absolute gap, but not a relative gap
    # estimate absolute gap from objective function for relaxed solution
    relaxed <- solve_relaxed_clp(cost, rij, targets)
    gap <- gap * relaxed$objval
    rm(relaxed)
    results <- Rsymphony::Rsymphony_solve_LP(
      # objective function
      obj = cost,
      # structural constraints
      mat = rij,
      rhs = targets,
      dir = rep(">=", length(targets)),
      # binary decision variables
      types = "B",
      # goal is to minimize objective function
      max = FALSE,
      # gap to optimality
      gap_limit = gap,
      # stop after specified number of seconds
      time_limit = ifelse(is.finite(time_limit), time_limit, -1),
      # first feasible solution
      first_feasible = first_feasible
    )
  })
  # prepare return object
  list(time = summary(t)[["user"]],
       x = results$solution,
       objval = results$objval,
       objbound = bound,
       gap = (results$objval / bound - 1))
}
# glpk
msc_glpk <- function(cost, rij, targets,
                     gap = 1e-4,
                     time_limit = Inf,
                     bound = NA) {
  # initialize an empty model
  model <- glpkAPI::initProbGLPK()
  glpkAPI::setProbNameGLPK(model, "reserve-design")
  # goal is to minimize objective function
  glpkAPI::setObjDirGLPK(model, glpkAPI::GLP_MIN)
  # initialize decision variables
  glpkAPI::addColsGLPK(model, ncols = length(cost))
  # objective function
  # also specify no bounds on decision variables
  glpkAPI::setColsBndsObjCoefsGLPK(model, j = seq_along(cost),
                                   lb = NULL, ub = NULL,
                                   obj_coef = cost,
                                   type = rep(glpkAPI::GLP_FR, length(cost)))
  # binary decision variables
  glpkAPI::setColsKindGLPK(model, j = seq_along(cost),
                           kind = rep(glpkAPI::GLP_BV, length(cost)))
  # structural constraints
  # initialize
  glpkAPI::addRowsGLPK(model, nrows = length(targets))
  # set non-zero elements of constraint matrix
  glpkAPI::loadMatrixGLPK(model, ne = length(rij$v),
                          ia = rij$i, ja = rij$j, ra = rij$v)
  # rhs
  glpkAPI::setRowsBndsGLPK(model, i = seq_along(targets),
                           lb = targets, ub = NULL,
                           type = rep(glpkAPI::GLP_LO, length(targets)))
  # presolve and automatically calculate relaxed solution
  # otherwise glpkAPI::solveSimplexGLPK(model) must be called first
  glpkAPI::setMIPParmGLPK(PRESOLVE, GLP_ON)
  glpkAPI::setMIPParmGLPK(MSG_LEV, GLP_MSG_ALL)
  # gap to optimality
  glpkAPI::setMIPParmGLPK(MIP_GAP , gap)
  # stop after specified number of seconds, convert to milliseconds
  if (is.finite(time_limit)) {
    glpkAPI::setMIPParmGLPK(TM_LIM, 1000 * time_limit)
  }
  
  # solve
  t <- system.time({
    screen_out <- capture.output(glpkAPI::solveMIPGLPK(model))
  })
  # extract lower bound from screen output
  if (is.na(bound)) {
    bound <- stringr::str_subset(screen_out, "^\\+")
    bound <- stringr::str_subset(bound, ">=\\s+(-?[+.e0-9]+)")
    bound <- stringr::str_match(bound, ">=\\s+(-?[+.e0-9]+)")
    bound <- ifelse(nrow(bound) > 0, as.numeric(bound[nrow(bound), 2]), NA)
  }
  # prepare return object
  results <- list(time = summary(t)[["user"]],
                  x = glpkAPI::mipColsValGLPK(model),
                  objval = glpkAPI::mipObjValGLPK(model),
                  objbound = bound,
                  gap = (glpkAPI::mipObjValGLPK(model) / bound - 1))
  glpkAPI::delProbGLPK(model)
  return(results)
}
```

## Gurobi

[Gurobi](http://gurobi.com) is a cutting edge commercial optimization solver. It's extremely fast, has an easy to use R interface, and can solve both linear and quadratic programs. The downside is that for many conservation applications it's prohibitively expensive at $12,000 for a single license, hence there is a need a viable free open source alternative. I treat Gurobi first since it will be the gold standard against which the remaining free alternatives will be measured.

```r
msc_gurobi(cost, rij, targets,
           gap = 1e-4, time_limit = Inf, first_feasible = FALSE,
           bound = NA)
```

## lp_solve

`lp_solve` is a open source ILP solver that is best accessed with the `lpSolveAPI` package, which provides a low-level API interface for building and solving linear programs .

```r
msc_lpsolve(cost, rij, targets,
            gap = 1e-4, time_limit = Inf, first_feasible = FALSE,
            bound = NA)
```

## SYMPHONY

[SYMPHONY](https://projects.coin-or.org/SYMPHONY) is another open-source integer programming solver. It's part of the [Computational Infrastructure for Operations Research](http://www.coin-or.org/) (COIN-OR) project, an initiative to promote development of open-source tools for operations research (a field that includes linear programming). The `RSymphony` package provides a convenient R interface to this solver.

```r
msc_symphony(cost, rij, targets,
             gap = 1e-4, time_limit = Inf, first_feasible = FALSE,
             bound = NA)
```

## GLPK

The [GNU Linear Programming Kit](https://www.gnu.org/software/glpk/) is an open-source package for solving linear and integer linear programs. The R package `glpkAPI` provides a more feature rich interface to the low-level GLPK API.

```r
msc_glpk(cost, rij, targets,
         gap = 1e-4, time_limit = Inf,
         bound = NA)
```

# Stopping conditions

For simple problems, these solvers will all find the true optimal solution. However, in general, this will not be possible due to computational constraints and time limitations. Therefore, it's usually necessary to tell the solvers to stop early and I've built in three stopping conditions to do this. Before looking at performance, I'll see how these solvers deal with the stopping conditions.

I'll start by finding the exact solution with Gurobi. This will facilitate evaluating how well each solver does.

```{r exact, eval=-1:2, echo=-2:3}
exact <- msc_gurobi(cost, rij, targets, gap = 0)
saveRDS(exact, "data/ilp-performance/exact.rds")
exact <- readRDS("data/ilp-performance/exact.rds")
exact_val <- exact$objval
```

## Time limit

The simplest approach is to give the solver a time limit and ask it to return the best solution obtained after it's run for that amount of time. I'll give each solver 5 seconds to work on the problem defined above.

```{r time-limit, results='hide'}
tl_lpsolve <- msc_lpsolve(cost, rij, targets, time_limit = 5, bound = exact_val)
tl_symphony <- msc_symphony(cost, rij, targets, time_limit = 5, bound = exact_val)
tl_glpk <- msc_glpk(cost, rij, targets, time_limit = 5, bound = exact_val)
```

The run times are all about 5 seconds as desired.

```{r tl_times}
tl_lpsolve$time
tl_symphony$time
tl_glpk$time
```

All the solvers got fairly close to optimality.

```{r tl_gap}
# % gap to optimality
100 * tl_lpsolve$gap
100 * tl_symphony$gap
100 * tl_glpk$gap
```

Usually time is the limiting factor in an analysis, and specifying the run time allows you to control this. Therefore it's usually the best place to start. Run the solver for a reasonable amount of time, then inspect the solution to see how close to optimality it is. Depending on the results you may want to run the solver for a longer time or with a gap specified.

## First feasible

These solvers all start by solving the relaxed problem, which is the optimization problem without the constraint that all the decision variables are integer, then work to find solutions that do meet the integrality constraints. The first solution that meets all the constraints is called the first feasible solution. All the packages, except `glpkAPI`, give the option of returning this solution. Unless you're lucky this won't be the true optimuum, but it's often pretty good because it's not just any feasible solution, it's one derived from the optimal relaxed solution.

```{r first-feasible, results='hide'}
ff_lpsolve <- msc_lpsolve(cost, rij, targets, first_feasible = TRUE,
                          bound = exact_val)
ff_symphony <- msc_symphony(cost, rij, targets, first_feasible = TRUE,
                            bound = exact_val)
```

This approach has the benefit of being a the quickest way to get a feasible solution.

```{r ff_times}
ff_lpsolve$time
ff_symphony$time
```

However, note that `lpSolveAPI` does no better than this first feasible solution when allowed to run longer. In fact, even allowing it to run *much* longer has no impact, the returned solution is still the first feasible solution.

```{r times}
# ratio of objective function values, first feasible / 5 second run
ff_lpsolve$objval / tl_lpsolve$objval
ff_symphony$objval / tl_symphony$objval
```

Requesting the first feasible solution is a good approach if you're more concerned with time that getting a solution close to optimality. This will get you a solution that satifies all the constraints quickest.

## Gap to optimality

These solvers all use some variation of an algorithm called [branch and bound](http://www.gurobi.com/resources/getting-started/mip-basics). One of the key features of this algorithm is that it calculates and constantly refines upper and lower bounds on the objective function. The difference between the upper and lower bounds is known as the **gap** and gives an estimate of how close the current best solution is to the true global optimum. As the algorithm progresses, and the solution is refined, this gap becomes smaller until eventually is becomes zero when the global optimum is found. However, the algorithm can also stop at any point and return the current best solution along with an estimate of the quality of the solution (i.e. the gap).

Here I'll request that the solvers return when they get within 0.1% from the optimal solution.

```{r one-pct, results='hide'}
gap_lpsolve <- msc_lpsolve(cost, rij, targets, gap = 0.001, time_limit = 60,
                           bound = exact_val)
gap_symphony <- msc_symphony(cost, rij, targets, gap = 0.001, bound = exact_val)
gap_glpk <- msc_glpk(cost, rij, targets, gap = 0.001, bound = exact_val)
```

Note that for all three solvers, the 5 second run above was sufficient to get a solution within 1% of optimality. Despite this, when I ran `lpSolveAPI` for several minutes it never returned a solution, so I had to enforce a 60 second time limitThe gap that these solvers calculate is an upper bound, which is refined as the algorithm progresses. In contrast, I know exactly how far these solutions are from optimality since I found the optimum with Gurobi. Given that `lp_solve` isn't stopping execution despite having a solution within the specified gap, it suggests that something is wrong. Either `lp_solve` isn't doing a great job of estimating the objective function bounds, or there's an issue with the interface.

In addition, the gap that SYMPHONY takes is an absolute gap, rather than a relative gap like the other solvers. I've gotten around this by first solving the relaxed problem (i.e. with no constraint on decision variables being binary) with [Clp](https://projects.coin-or.org/Clp). The objective function for the relaxed solution is a lower bound on the objective function for the fully constrained problem, so multiplying it by the relative gap gives an estimate of the absolute gap. Ideally, I'd like to avoid this workaround since it does add to the execution time, but I see no other solution. 

```{r tl_times}
gap_lpsolve$time # set to stop at 60 seconds
gap_symphony$time
gap_glpk$time
```

All the solvers do much better than the desired 1%.

```{r tl_gap}
100 * gap_lpsolve$gap
100 * gap_symphony$gap
100 * gap_glpk$gap
```

## Bound

While all these solvers must internally calculate a lower bound on the objective function, none of the open-source solvers return these bounds in an easily accessible form. Knowing this lower bound is critical for calculating the quality of the solution (i.e. the gap to optimality). I've had to deal with getting a bound in a different manner for each solver:

- `gurobi`: conveniently returned as a component of the Gurobi results object (`result$objbound`).
- `lpSolveAPI`: printed to screen while lp_solve runs, however, it only allows for precision up to a tenth of a percent, anything below 0.1% appears as 0.0%. I extract this from the screen output with regular expressions.
- `Rsymphony`: not provided at all.
- `glpkAPI`: printed to screen when GLPK finishes, however, anthing below 0.1% appears as "< 0.1%). I extract this from the screen output with regular expressions.

So, really none of the open-source solvers really do a great job in this department, either the bound is missing or returned in a simplified form.

## Summary

Here are some general takeways from the above exploration with respect to stopping condition:

- `gurobi` can be used with a gap, a time limit, or to return the first feasible solution.
- `lpSolveAPI` can only be used to return the first feasible solution. Setting a gap doesn't appear to work and, even with a long time limit, `lp_solve` doesn't improve upon this first feasible solution.
- `Rsymphony` can be used with a gap, a time limit, or to return the first feasible solution, however, requires a workaround to convert a relative to absolute gap.
- `glpkAPI` works with either a gap or a time limit. There is no option to return the first feasible solution.

# Performance comparison

```{r}
x_rsymphony <- msc_symphony(cost, rij, targets, gap = 0.001, time_limit = 120,
                            bound = exact_val)
x_glpkapi <- msc_glpk(cost, rij, targets, gap = 0.001, time_limit = 240),
                      bound = exact_val)
```


```{r}
results_gurobi <- msc_gurobi(cost, rij, targets, time_limit = 10)
results_lpsolveapi <- msc_lpsolveapi(cost, rij, targets, time_limit = 10)
results_rsymphony <- msc_rsymphony(cost, rij, targets, time_limit = 10)
results_glpkapi <- msc_glpkapi(cost, rij, targets, time_limit = 10)

cost_big <- disaggregate(cost_raster, 10) %>% 
  {.[[1]][]}
species_big <- disaggregate(species, 10)
rij_big <- as.simple_triplet_matrix(t(unname(species_big[])))
targets_big <- 0.3 * cellStats(species_big, "sum")

results_gurobi <- msc_gurobi(cost_big, rij_big, targets_big,
                             gap = 1e-8, time_limit = 100)
results_lpsolveapi <- msc_lpsolveapi(cost_big, rij_big, targets_big,
                                     gap = 0.001, time_limit = 100,
                                     bound = results_gurobi$objbound)
# results_rsymphony <- msc_rsymphony(cost_big, rij_big, targets_big,
#                                    gap = 0.001, time_limit = 100,
#                                      bound = results_gurobi$objbound)
results_glpkapi <- msc_glpkapi(cost_big, rij_big, targets_big,
                               gap = 0.001, time_limit = 100,
                                     bound = results_gurobi$objbound)
results_gurobi$gap
results_lpsolveapi$gap
results_glpkapi$gap

results_gurobi$time
results_lpsolveapi$time
results_glpkapi$time
```

